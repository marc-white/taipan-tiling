***************
System overview
***************

This page is designed to provide a high-level overview of how the
tiling system works. This overview predominantly covers the
:ref:`taipan <taipan>`
module; users should review the TaipanDB documentation for how this is
interfaced with the database system. Simulator/scheduling operations
are described elsewhere (TBD).

Tiling
======

'Tiling' is the generic name for the procedure of assigning any kind of
target (science object, standard, guide, sky, ...) to a particular pointing
of the telescope. As the survey progresses, a series of circular 'tiles' are
built-up across the sky.

To implement this concept in code, we have developed Python objects
which represent targets in the Taipan survey, and the tiles they may be
assigned to.

:any:`TaipanTarget` objects
---------------------------

:any:`TaipanTarget` objects are basic representations of an astronomical target
for the Taipan survey. The same object class is used to represent all target
types, except for sky fibre positions (see
:ref:`fibrealloc` below). Each :any:`TaipanTarget` object has a set of
Boolean flags denoting which target type(s) it is (it is valid to have a
target used for multiple types; this is not used for Taipan, but, e.g.,
FunnelWeb targets can also act as standard targets as appropriate).

:any:`TaipanTile` objects
-------------------------

:any:`TaipanTile` objects are used to represent configurations of the TAIPAN
instrument. In essence, they are mappings of fibre numbers to
:any:`TaipanTarget` objects already in memory; the position of the fibre
is determined by the recorded position of the mapped :any:`TaipanTarget`. The
object also holds additional information, such as the tile's unique identifier,
field identifier, and other metadata.

Generating tiles
----------------

Single tiles may be generated by:

- Creating a new :any:`TaipanTile` object
- Use the :any:`TaipanTile.unpick_tile` function to assign
  targets to the tile from a pre-loaded list of
  candidate :any:`TaipanTarget` objects
- (Optionally) use the :any:`TaipanTile.repick_tile` function to ensure
  the optimal assignment of fibres to targets (in terms of fibre travel
  distance)

.. _target_selection:

Target selection
^^^^^^^^^^^^^^^^

Notionally, any target within a tile's field of view could be assigned to a
fibre on the tile (:any:`TaipanTile.assign_fibre`). However, there are several
things that need to be considered:

- What target selection scheme will satisfy the survey goals? Are there targets
  that are very important for you to observe as soon as possible, or are you
  more interested in getting an even distribution of a certain type of
  targets?
- Is the target you want currently excluded by other targets? The Starbugs in
  the Taipan instrument have a finite size, so assigning a particular target to
  a tile may exclude that tile from holding certain other targets.

Considering these points leads to the conclusion that some sort of target
prioritisation and ranking is required for the best possible survey
performance. The two key parameters when ranking targets are:

Priority
    Target priority is a user-defined number that attempts to parametrise how
    important the target is to the user. Higher values denote a greater
    importance attached to this target.

Difficulty
    A target's difficulty is defined as the number of targets this target would
    exclude if assigned to a tile. [#f_diff]_ The exclusion is due to the
    ceramic foot of the assigned Starbug (which has a known radius,
    :any:`taipan.core.FIBRE_EXCLUSION_RADIUS`) covering up the other targets.

Distance from the fibre can also be an consideration when determining
how to assign a single fibre (:any:`TaipanTile.assign_fibre`) as opposed to
configuring an entire tile (:any:`TaipanTile.unpick_tile`).

There are multiple ways these values can be combined; see the documentation
for :any:`TaipanTile.assign_fibre` for details. The way that Taipan chooses
to assign targets is the sequential method, with the highest priority target
being assigned first, and any ties settled by selection the most difficult
of those targets.

.. _fibrealloc:

Fibre allocation
^^^^^^^^^^^^^^^^

:ref:`target_selection` dealt with how to select a target for a given fibre.
This section discusses the optimal way to assign targets to a tile as a whole.

Notionally, it would be perfectly valid to call :any:`TaipanTile.assign_fibre`
for each fibre of a tile in sequence. However, there are some penalties
associated with this:

- It's up to the user to determine the best schema for assigning sky, standard
  and guide targets; should they be assigned before or after science targets?
- Multiple calls to :any:`TaipanTile.assign_fibre` will invoke the
  re-computation of the target ranking list for each fibre; on the scale of a
  tile, it is more efficient to calculate this ranking list just once, and use
  it to populate all fibres.

To this end, :any:`taipan.core.TaipanTile` have a built-in
:any:`TaipanTile.unpick_tile` method, which will assign targets to,
or 'unpick', an entire tile. The algorithm for doing this is as follows:

1. Sky fibres are assigned semi-randomly using the :any:`TaipanTile.assign_sky`
   method. It is also possible to assign sky fibres to whatever fibres are
   left over after all other target types have been assigned;
2. Science targets are assigned as per :ref:`target_selection`; however,
   instead of each fibre being allocated a target in sequence, the
   highest-ranked target in the tile is assigned to the nearest available fibre.
   This process is repeated until a full allocation of science targets is made;
3. Assign the required number of standard and guide targets. If the minimum
   number of standard (:any:`taipan.core.STANDARDS_PER_TILE_MIN`) or
   guide (:any:`taipan.core.GUIDES_PER_TILE_MIN`) cannot be reached in the
   current configuration, science targets are removed from the tile to allow
   these limits to be reached.
4. If any normal fibres remain available, further science targets are assigned
   until the list is exhausted or all fibres are assigned.

Note that sky positions are *not* handled by :ref:`taipan`. Fibres assigned to
sky receive a special value of ``'sky'`` instead of a reference to a
:ref:`taipan.core.TaipanTarget`. A separate software routine (Cone of Darkness)
will attempt to position fibres assigned as sky around the assigned target.
Cone of Darkness has authority to switch fibre assignments to assist it in
placing the sky fibres.

.. _simulation:

Simulation
==========

The contents of :any:`taipan.simulate` are designed to fulfil two goals:

- Provide datasets to validate the performance of the Taipan scheduling
  algorithm(s);
- Prototype and test code that will eventually be adapted for
  :ref:`live operations <live-operations>`.

General outline
---------------

At its simplest, the ``execute`` function within each :any:`taipan.simulate`
simulation module (modules named or starting with ``fullsurvey``) runs the
:any:`taipan.simulate.fullsurvey.sim_do_night` function in a loop between a
specified start and end date. The exact arguments provided to
:any:`sim_do_night <taipan.simulate.fullsurvey.sim_do_night>` for each night
depends on the logic built into the individual simulation.

Different simulations may also have special events that occur during the
simulation run (for example, a switch over to observing with a full
300-fibre configuration, and an associated loss of time while the fibre
change is implemeted). Refer to the documentation of the modules within
:any:`taipan.simulate` for more details.

.. _live-operations:

Live Operations
===============

Live operations have yet to be implemented. However, this should be a fairly
straightforward re-packaging of the :ref:`simulation` code,
to be triggered
by the :any:`Jeeves` virtual observer at the appropriate times.

.. _nightly-plan:

Nightly observing plan
----------------------

The initial imagined workflow is as follows:

1. During day time, the code will plan (using
   :any:`taipan.simulate.fullsurvey.sim_do_night`, with the appropriate
   parameters,) observations for the upcoming
   evening.
   With the ``instant_dq`` option disabled (and fake data quality analysis
   disabled as well), the remaining tiles will be set as ``queued`` in the
   database.
2. Observing definition files for each queued tile will be written to a
   specified location in the Taipan computing architecture. These tiles will
   contain timestamps in their filenames, allowing :any:`Jeeves` to identify
   which tile to observe when.
3. :any:`Jeeves` will attempt to execute the night's observing plan, as implied
   by the observing definition files present. Not all tiles may be executed due
   to, e.g., weather losses, and on tiles that are observed, not every target
   may be successfully observed.
4. Throughout the night and into the morning, the :any:`TLDR` data reduction
   system will be processing incoming data, and writing the results
   (success/failure) of observations back to the managing database.
5. Once data reduction is complete, all fields affected by the night's
   observations will be re-tiled, removing any existing prepared but unobserved
   tiles for those
   fields. This has the effect of folding-in the results from the night's
   observations.

At this point, the sequence returns to step 1.

Under this scheme, the tiling/scheduling code has no work to do overnight.
It is considered wise to allow the scheduler to run during the day in
the first instance, allowing
human operators to confirm it is operating correctly before observations begin.

In the event of a failure during the night (e.g. telescope problem, inclement
weather etc.), :any:`Jeeves` should attempt to pick up the observing program
at the time when the failure resolves. Tiles scheduled for the lost period of
time will not be observed.

Live scheduling
---------------

A later goal of the survey is to implement live re-scheduling. The scheme for
this would be as follows:

1. At any point during the night, :any:`Jeeves` may request a tile from the
   scheduler.
2. The scheduler will run :any:`taipan.simulate.fullsurvey.select_best_tile`
   for the
   current time, and return that tile to :any:`Jeeves` for observation. This
   tile will be set to 'queued' within the database.
3. After handing off the tile for observation, a call to
   :any:`taipan.simulate.utils.tiling.retile_fields` will be made automatically
   to regenerate
   tiles for the region affected by the current observation.
4. Steps 1 to 3 will repeat throughout the night until :any:`Jeeves` requests
   no further Taipan observations.
5. Throughout the night and into the morning, the :any:`TLDR` data reduction
   system will be processing incoming data, and writing the results
   (success/failure) of observations back to the managing database. If this
   occurs during the night, success/failure feedback will be incorporated into
   the dynamic re-tiling of affected regions of the sky (with a delay
   time corresponding to how long it takes :any:`TLDR` to process an
   observation).
6. During the day, a full re-tile of all regions observed/affected during the
   night will take place once :any:`TLDR` has finished analyzing the
   data from the previous night.

There are a few extra failure modes that need to be considered under this
scheduling schema compared to having :ref:`a nightly plan <nightly-plan>`.

Failure between observations
    This is easily managed - :any:`Jeeves` just won't request a new tile!
Failure after tile has been requested
    :any:`Jeeves` will notify the tiling system that the tile has been pulled
    out of the system, but not observed, and send it back. The scheduler
    will then:

    - Wait for any running re-tiling in that area to complete;
    - Reset the missed tile's status to 'unqueued'
    - Re-tile any affected tiles (which effectively re-introduces the missed
      targets to the target pool)
Failure during observation
    The exact action to take in this case probably depends on the type of the
    failure:

    - Failures that will extend for a period of time (e.g. inclement
      weather or telescope failure setting in halfway through an observation)
      can be sent back to the scheduling syste, as if it were a failure after
      the tile has been requested.
    - Brief failures should simply be treated as poor-quality science
      observations, and folded back into the re-tiling of further tiles
      as per the standard operating sequence.



.. rubric:: Footnotes

.. [#f_diff] A target is included in its own difficulty count, so the minimum
             possible target difficulty is 1. This avoids problems when
             attempting to multiply/divide by the difficulty, as well as the
             need to strip input lists of the calling target.
